<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Noel Tree Mobile Optimized</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; touch-action: none; }
        canvas { display: block; }
        #ui {
            position: absolute; top: 10px; left: 10px; right: 10px; z-index: 10;
            background: rgba(0, 0, 0, 0.7); color: white; padding: 15px;
            border-radius: 12px; border: 1px solid #f1c40f;
            backdrop-filter: blur(8px); pointer-events: none;
            font-size: 13px;
        }
        .status { position: fixed; bottom: 15px; width: 100%; text-align: center; color: #f1c40f; font-weight: bold; font-size: 14px; z-index: 5; }
        #loading-screen {
            position: fixed; inset: 0; background: #000; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center; color: #f1c40f;
        }
    </style>
</head>
<body>

    <div id="loading-screen">
        <div style="font-size: 24px; margin-bottom: 10px;">üéÑ</div>
        <div>ƒêang chu·∫©n b·ªã c√¢y th√¥ng...</div>
    </div>

    <div id="ui">
        <h3 style="margin:0 0 5px 0; color: #f1c40f; font-size: 16px;">Xmas Tree Reveal</h3>
        <p style="margin:0; opacity: 0.9;">
            ‚Ä¢ <b>Di chuy·ªÉn:</b> ƒê∆∞a tay tr√°i/ph·∫£i.<br>
            ‚Ä¢ <b>M·ªü qu√†:</b> Bung ng√≥n tay ƒë·ªÉ hi·ªán ·∫£nh.
        </p>
    </div>

    <div id="status" class="status">Kh·ªüi ƒë·ªông Camera...</div>
    <video id="input_video" playsinline style="display:none;"></video>

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        const statusEl = document.getElementById('status');
        const videoElement = document.getElementById('input_video');

        const imageUrls = [
            '1.jpg',
            '2.jpg',
            '3.jpg',
            '4.jpg'
        ];

        // --- 1. Three.js Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: !isMobile }); // T·∫Øt kh·ª≠ rƒÉng c∆∞a tr√™n mobile ƒë·ªÉ m∆∞·ª£t h∆°n
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);
        
        // ƒêi·ªÅu ch·ªânh kho·∫£ng c√°ch camera d·ª±a tr√™n m√†n h√¨nh d·ªçc/ngang
        camera.position.z = isMobile ? 14 : 11;
        camera.position.y = 3;

        const treeGroup = new THREE.Group();
        scene.add(treeGroup);

        const treeElements = [];
        
        function createTree() {
            // Ng√¥i sao
            const starGeo = new THREE.OctahedronGeometry(0.5, 0);
            const starMat = new THREE.MeshBasicMaterial({ color: 0xfff100 });
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.y = 7.5;
            addTreeElement(star);

            // Th√¢n c√¢y (Gi·∫£m s·ªë h·∫°t tr√™n mobile ƒë·ªÉ t·ªëi ∆∞u)
            const count = isMobile ? 1200 : 2500;
            for (let i = 0; i < count; i++) {
                const y = Math.random() * 8 - 1;
                const radiusAtHeight = (7 - y) * 0.5;
                const theta = Math.random() * Math.PI * 2;
                
                const x = radiusAtHeight * Math.cos(theta);
                const z = radiusAtHeight * Math.sin(theta);

                let mesh;
                const r = Math.random();
                if (r > 0.94) {
                    mesh = new THREE.Mesh(new THREE.SphereGeometry(0.18, 6, 6), new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xaa0000 }));
                } else if (r > 0.6) {
                    mesh = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.1), new THREE.MeshStandardMaterial({ color: 0xf1c40f, emissive: 0x443300 }));
                } else {
                    mesh = new THREE.Mesh(new THREE.SphereGeometry(0.04, 4, 4), new THREE.MeshBasicMaterial({ color: 0xf1c40f }));
                }
                mesh.position.set(x, y, z);
                addTreeElement(mesh);
            }
            scene.add(new THREE.AmbientLight(0x404040, 2));
            const pLight = new THREE.PointLight(0xfff100, 15, 20);
            pLight.position.set(0, 5, 5);
            scene.add(pLight);
        }

        function addTreeElement(m) {
            m.userData.orig = m.position.clone();
            m.userData.vel = new THREE.Vector3((Math.random()-0.5)*4, (Math.random()-0.5)*4, (Math.random()-0.5)*4);
            treeElements.push(m);
            treeGroup.add(m);
        }

        // --- ·∫¢nh ---
        const loader = new THREE.TextureLoader();
        const textures = imageUrls.map(url => loader.load(url));
        let currentIdx = 0;
        const spriteMat = new THREE.SpriteMaterial({ map: textures[0], transparent: true, opacity: 0 });
        const photo = new THREE.Sprite(spriteMat);
        photo.scale.set(isMobile ? 6 : 8, isMobile ? 6 : 8, 1);
        photo.position.y = 3;
        scene.add(photo);

        // --- AI Control ---
        let targetScale = 1.0, currentScale = 1.0, wasIn = true;

        function onResults(results) {
            document.getElementById('loading-screen').style.display = 'none';
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const hand = results.multiHandLandmarks[0];
                const d = Math.hypot(hand[4].x - hand[8].x, hand[4].y - hand[8].y);
                targetScale = THREE.MathUtils.mapLinear(d, 0.05, 0.4, 1.0, 5.0);
                treeGroup.position.x = (0.5 - hand[0].x) * (isMobile ? 10 : 15);

                if (targetScale < 1.3) wasIn = true;
                if (targetScale > 2.8 && wasIn) {
                    currentIdx = (currentIdx + 1) % textures.length;
                    photo.material.map = textures[currentIdx];
                    wasIn = false;
                }
                statusEl.innerText = targetScale > 2.5 ? "‚ú® ƒêANG M·ªû QU√Ä ‚ú®" : "üéÑ C√ÇY TH√îNG NOEL üéÑ";
            }
        }

        const hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
        hands.setOptions({ maxNumHands: 1, modelComplexity: isMobile ? 0 : 1, minDetectionConfidence: 0.6 });
        hands.onResults(onResults);

        const cameraAI = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: isMobile ? 480 : 640, height: isMobile ? 640 : 480
        });
        cameraAI.start();

        function animate() {
            requestAnimationFrame(animate);
            currentScale += (targetScale - currentScale) * 0.1;
            const ex = (currentScale - 1) * 2.5;
            
            treeElements.forEach(m => {
                m.position.x = m.userData.orig.x + m.userData.vel.x * ex;
                m.position.y = m.userData.orig.y + m.userData.vel.y * ex;
                m.position.z = m.userData.orig.z + m.userData.vel.z * ex;
            });

            treeGroup.rotation.y += 0.01;
            const op = THREE.MathUtils.mapLinear(currentScale, 1.8, 4.0, 0, 1);
            photo.material.opacity = THREE.MathUtils.clamp(op, 0, 1);
            photo.position.x = treeGroup.position.x;

            renderer.render(scene, camera);
        }

        createTree();
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.position.z = window.innerHeight > window.innerWidth ? 14 : 11;
        });
    </script>
</body>
</html>